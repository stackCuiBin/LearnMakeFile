第1课 make和makefile
1，make是一个应用程序
	解析源程序之间的依赖关系
	根据依赖关系自动维护编译工作
	执行宿主操作系统中的各种命令

2，makefile是一个描述文件
	定义一系列的规则来指定源文件编译的先后顺序
	拥有特定的语法规则，支持函数定义和函数调用
	能够直接集成操作系统中的各种命令

3，最简单的makefile示例
	hello：
		echo "hello makefile"
	目标	实现目标所执行的命令
注意：目标后的命令需要用tab键('\t')隔开。

4，make程序的使用示例
	make -f mf.txt hello
功能说明：
	以hello关键字作为目标查找mf.txt文件，并执行hello处的命令。

5，make程序的简写示例
	make hello
功能说明：
	以hello关键字作为目标查找makefile或者Makefile文件，并执行hello处的命令。

	make
功能说明：
	查找makefile或Makefile文件中最顶层目标，并执行最顶层目标的命令。

小结：
	make只是一个特殊功能的应用程序
	make用于根据指定的目标执行相应的命令
	makefile用于定义目标和实现目标所需的命令
	makefile有特定的语法规则，支持函数定义和调用

第2课 初识makefile的结构
1，makefile的意义
	makefile用于定义源文件间的依赖关系
	makefile说明如何编译各个源文件并生成可执行文件
依赖的定义：
	targets : prerequistes ; command1
		('\t')command2

2, makefile中的元素含义
	targets
		通常是需要生成的目标文件名
		make所需执行的命令名称
	prerequisites
		当前目标所依赖的其它目标或文件
	command
		完成目标所需要执行的命令

3，规则中的注意事项
	targets可以包含多个目标
		使用空格对多个目标名进行分隔
	prerequisites可以包含多个依赖
		使用空格对多个依赖进行分隔
	tab键：'\t'
		每一个命令行必须以tab字符开始
		tab字符告诉make此行是一个命令行
	续行符：\
		可以将内容分开写到下一行，提高可读性

4，依赖规则
	当目标对应的文件不存在，执行对应命令
	当依赖在时间上比目标更新，执行对应命令
	当依赖关系连续发生时，对比依赖链上的每一个目标

5，小技巧
	makefile中可以在命令前加上@符，作用为命令无回显
	工程开发中可以将最终可执行文件名和all同时作为makefile中第一条规则的目标。
	hello.out all : main.c
		gcc -o hello.out main.o

小结：
	makefile用于定义原文件间的依赖关系
	makefile说明如何编译各个源文件并生成可执行文件
	makefile中的目标之间存在连续依赖关系
	依赖存在并且命令执行成功时目标完成的充要条件

第3课 伪目标的引入
1，makefile中的伪目标
	通过.PHONY关键字声明一个伪目标
	伪目标不对应任何实际的文件
	不管伪目标的依赖是否更新，命令总是执行

2，伪目标的语法：先声明，后使用
	本质：
	伪目标是make中的特殊目标.PHONY的依赖
	.PHONY : clean
	## 注释 ##
	clean :
		command

3, 伪目标的妙用：规则调用(函数调用)
	.PHONY : clean rebuild all
	## other rules ##
	rebuild : clean all
	clean : 
		command
原理：当一个目标的依赖包含伪目标时伪目标所定义的命令总是会被执行。

技巧：绕开.PHONY关键字定义伪目标
原理：如果一个规则没有命令或者依赖，并且它的目标不是一个存在的文件名；
在执行此规则时，目标总会被认为是最新的。
	clean : FORCE
		command
	FORCE :

第4课 变量和不同的赋值方式
makefile中支持程序设计语言中变量的概念
makefile中的变量只代表文本数据(字符串)
makefile中的变量名规则
	- 变量名可以包含字符，数字，下划线
	- 不能包含":","#","="或" "
	- 变量名大小写敏感
	
1，变量的定义和使用
	CC := gcc
	TARGET := hello.out
	
	$(TARGET) : main.o
		$(CC) -o $(TARGET) main.o

2, makefile中变量赋值方式
	- 简单赋值( := )
	- 递归赋值( = )
	- 条件赋值( ?= )
	- 追加赋值( += )

3, 简单赋值
	程序设计语言中的通用的赋值方式
	只针对当前语句的变量有效
	x := foo
	y := $(x)b
	x := new
	.PHONY : test
	test :
		@echo "x => $(x)"
		@echo "y => $(y)"
	输出： x => new; y => foob
	
4, 递归赋值
	赋值操作可能影响多个其它变量
	所有与目标变量相关的其它变量都将受到影响
	x := foo
	y := $(x)b
	x := new
	输出： x => new; y => newb
	
5，条件赋值
	如果变量未定义，使用赋值符号中的值定义变量
	如果变量已经定义，赋值无效
	x := foo
	y := $(x)b
	x ?= new
	输出： x => foo; y => foob
	
6，追加赋值
	原变量之后加上一个新值
	原变量值与新值之间由空格隔开
	x := foo
	y := $(x)b
	x += $(y)
	输出： x => foo foob; y => foob
	
第5课 预定义变量的使用
1，预定义变量的使用
在makefile中存在一些预定义的变量
	自动变量
		$@ 当前规则中触发命令被执行的目标
		$^ 当前规则中的所有依赖
		$< 当前规则中的第一个依赖
	特殊变量
		$(MAKE) 当前make解释器的文件名
		$(NAKECMDGOALS) 命令行中指定的目标名(make的命令行参数)
		$(MAKEFILE_LIST) make所需要处理的makefile文件列表，当前makefile的文件名总是位于列表最后
						文件名之间以空格进行分隔
		$(MAKE_VERSION) 当前make解释器的版本
		$(CURDIR) 当前make解释器的工作目录
		$(.VARIABLES) 所有已定义的变量名列表(预定义变量和自定义变量)
		...

示例：
	all : first second third
		@echo "\$$@ => $@"
		@echo "$$^ => $^"
		@echo "$$< => $<"
		
注意：
1，"$"对于makefile有特殊含义，输出时需要加上一个"$"
2，"$@"对于Base Shell有特殊含义，输出时需要加上"\"进行转义

第6课 变量的高级主题-上
1，变量值的替换
	使用指定字符(串)替换变量值中的后缀字符(串)
	语法格式：$(var:a=b)或${var:a=b}
		替换表达式中不能有任何的空格
		make中支持使用${}对变量进行取值
		
2，变量的模式替换
	使用%保留变量值中的指定字符，替换其它字符
	语法格式: $(var:a%b=x%y)或${var:a%b=x%y}
		替换表达式中不能有任何的空格
		make中支持使用${}对变量进行取值
		
3，规则中的模式替换
	targets : target-pattern : prereq-pattern
		command1
		command2
		...
意义：通过target-pattern从targets中匹配子目标；在通过prereq-pattern
从子目标生成依赖；进而构成完整的规则。
示例：
	OBJS := func.o main.o
	$(OBJS) : %.o : %.c
		gcc -o $@ -c $^
等价于
	func.o : func.c
		gcc -o $@ -c $^
	main.o : main.c
		gcc -o $@ -c $^

4，变量值的嵌套引用
	一个变量名之中可以包含对其它变量的引用
	嵌套引用的本质是使用一个变量表示另外一个变量
	x := y
	y := z
	a := $($(x))
	=> a := $(y) => a := z
	
5，命令行变量
	运行make时，在命令行定义变量
	命令行变量默认覆盖makefile中定义的变量
	注意：命令行变量不能有空格(a:=b)
	
6，override关键字
	用于指示makefile中定义的变量不能被覆盖
	变量的定义和赋值都需要使用override关键字
	
7，define关键字
	用于在makefile中定义多行变量
	多行变量的定义从变量名开始到endef结束
	可使用override关键字防止变量被覆盖
	define定义的变量等价于使用 = 定义的变量
override define cmd
	@echo "run cmd ls ..."
	@echo ls
endef

第7课 变量的高级主题-下
1，环境变量(全局变量)
	makefile中能够直接使用环境变量的值
		定义了同名变量，环境变量将被覆盖
		运行make时指定"-e"选项，优先使用环境变量
	为什么要在makefile中使用环境变量？
		优势：环境变量可以在所有makefile中使用
		劣势：过多的依赖于环境变量会导致移植性降低
		
2，变量在不同makefile之间的传递方式
	直接在外部定义环境变量进行传递
	使用export定义比那辆进行传递(定义临时环境变量)
	定义make命令行变量进行传递(推荐)

3，目标变量(局部变量)
	作用域只在指定目标及连带规则中
	target : name <assignment> value
	target : override name <assignment> value
	
4，模式变量
	模式变量是目标变量的扩展
	作用域只在符合模式的目标及连带规则中
	pattern : name <assignment> value
	pattern : override name <assignment> value
	
第8课 条件判断语句
1，makefile中支持条件判断语句
	可以根据条件的值来决定make的执行
	可以比较两个不同变量或者变量和常量值
	if*** (arg1,arg2)
	# for true
	else
	# for false
	endif
注意事项：条件判断语句只能用于控制make实际执行的语句；但是不能控制规则中命令的执行过程。

2，条件判断语句语法说明
	常用形式
		if*** (arg1,arg2)
	其它合法形式
		if*** "arg1" "arg2"
		if*** 'arg1' "arg2"
		if*** "arg1" 'arg2'
		if*** 'arg1' 'arg2'
注意：
	 	   		不能有空格(arg1,arg2)
[space]if***[space](arg1,arg2)[space]    

3，条件判断关键字
	ifeq	判断参数是否相等，相等为true，否则为false
	ifneq	判断参数是否不相等，不相等为true，否则为false
	ifdef	判断变量是否有值，有值为true，否则为false
	ifndef	判断参数是否没有值，没有值为true，否则为false

4，工程经验
	条件判断语句之前可以有空格，但不能有Tab字符('\t')
	在条件语句中不要使用自动变量($@, $^, $<)
	一条完整的条件语句必须位于同一个makefile中
	条件判断类似C语言中的宏，预处理阶段有效，执行阶段无效
	make在加载makefile时
		首先计算表达式的值(赋值方式不同，计算方式不同)
		根据判断语句的表达式决定执行的内容
		
第9课 函数定义及调用
1，makefile中支持函数的概念
	make解释器提供了一系列的函数供makefile调用
	在makefile中支持自定义函数实现，并调用执行
	通过define关键字实现自定义函数
	
2，自定义函数语法
函数定义：
	define func1
		@echo "My name is $(0)."
	endef
	
	define func2
		@echo "My name is $(0)."
		@echo "Param => $(1)"
	endef
	
函数调用：
	test :
		$(call func1)
		$(call func2, chichi)

3，深入理解自定义函数
	自定义函数是一个多行变量，无法直接调用
	自定义函数是一种过程调用，没有任何的返回值
	定义函数用于定义命令集合，并应用于规则中

4，make解释器中的预定义函数
	make的函数提供了处理文件名，变量和命令的函数
	可以在需要的地方调用函数来处理指定的参数
	函数在调用的地方被替换为处理结果
5, 预定义函数的调用
	var := $(func_name arg1,arg2, ...)
	为什么和自定义函数调用方式不同？
	本质剖析：
		makefile中不支持真正意义上的自定义函数
		自定义函数的本质是多行变量
		预定义的call函数在调用时将参数传递给多行变量
		自定义函数是call函数的实参，并在call中被执行

第10课 变量与函数的综合示例
1，实战需求
	自动生成target文件夹存放可执行文件
	自动生成objs文件夹存放编译生成的目标文件(*.o)
	支持调试版本的编译选项
	考虑代码的扩展性
	
2，工具原料
	$(wildcard _pattern)
		获取当前工作目录中满足_pattern的文件或目录列表
	$(addprefix _prefix,_names)
		给名字列表_names中的每一个名字增加前缀_prefix

3，关键技巧
	自动获取当前目录下的源文件列表(函数调用)
		SRCS := $(wildcard *.c)
	根据源文件列表生成目标文件列表(变量的值替换)
		OBJS := $(SRCS:.c=.o)
	对每一个目标文件列表加上路径前缀(函数调用)
		OBJS := $(addprefix path/, $(OBJS))
		
4，规则中的模式替换(目录结构)
	工作目录中存在func.c和main.c
	(%.o用于将%.c匹配成功的文件名进行模式替换，.c替换为.o)
	%.o : %.c
		gcc -o $@ -c $^
	相当于
	func.o : func.c
		gcc -o $@ -c $^
	main.o : main.c
		gcc -o $@ -c $^

小结
	目录可以成为目标的依赖，在规则中创建目录
	预定义函数是makefile实战中不可或缺的部分
	规则中的模式匹配可以直接针对目录中的文件
	可以使用命令行变量编译特殊的目标版本

第11课 自动生成依赖关系-上
1，值得思考的问题
	目标文件(.o)是否只依赖于源文件(.c)？
	编译器如何编译源文件和头文件？
	
2，编译行为带来的缺陷
	预处理器将头文件中的代码直接插入源文件
	编译器只通过预处理后的源文件产生目标文件
	因此，规则中以源文件为依赖，命令可能无法执行

3，试验中解决方案的问题
	头文件作为依赖存在于每个目标对应的规则中
	当头文件改动，任何源文件都将被重新编译(编译低效)
	当项目中头文件数量巨大时，makefile将很难维护
	
4，解决想法
	通过命令自动生成对头文件的依赖
	将生成的依赖自动包含进makefile中
	当头文件改动后，自动确认需要重新编译的文件

5，预备工作(原材料)
	Linux命令sed
	编译器依赖生成选项gcc -MM(gcc -M)
	
(1) Linux中的sed命令
	sed是一个流编辑器，用于流文本的修改(增删改查)
	sed可用于流文本中的字符串替换
	sed的字符串替换方式为： sed 's:src:des:g'
	e.g. echo "test=>abc+abc=abc" | sed 's:abc:xyz:g'
			=> test=>xyz+xyz=xyz
	sed的正则表达式支持
		在sed中可以用正则表达式匹配替换目标
		并且可以使用匹配的目标生成替换结果
				   正则表达式匹配目标
			sed 's,\(.*\)\.o[ :]*,objs/\1.o : ,g'
								  将匹配结果进行替换
			\(.*\)\.o表示匹配*.o的内容
			\1表示第一对括号里的内容

(2) gcc关键编译选项
	生成目标的完整依赖关系
		gcc -M test.c
	获取目标的部分依赖关系
		gcc -MM test.c

6，小技巧：拆分目标的依赖
	将目标的完整依赖拆分为多个部分依赖
	.PHONY : a b c
	test : a b c
		@echo "$^"
	等价于
	.PHONY : a b c
	test : a b
	test : b c
	test :
		@echo "$^"
	
第12课 自动生成依赖关系-中
1，makefile中的include关键字
	类似C语言中的include
	将其它文件内容原封不动的搬入当前文件
	语法： include filename
	例： include foo.make *.mk $(var)
	
2，make对include关键字的处理方式
	在当前目录搜索或指定目录搜索目标文件
		搜索成功：将文件内容搬入当前makefile中
		搜索失败：产生警告
			以文件名作为目标查找并执行对应规则
			当文件名对应的规则不存在时，最终产生错误

3，makefile中命令的执行机制
	规则中的每个命令默认是在一个新的进程中执行(shell)
	可以通过接续符(;)将多个命令组合成一个命令
	组合的命令依次在一个进程中被执行
	set -e指定发生错误后立即退出执行

4，解决方案的初步思路
	通过gcc -MM 和 sed 得到.dep依赖文件(目标的部分依赖)
		技术点：规则中命令的连续执行
	通过include指令包含所有的.dep依赖文件
		技术点：当.dep依赖文件不存在时，使用规则自动生成
	
第13课 自动生成依赖关系-下
1，include暗黑操作一：
	使用减号(-)不但关闭了include发出的警告，同时关闭了错误；
	当错误发生时make将忽略这些错误！！
	
2，include暗黑操作二：
	如果include触发规则创建了文件，之后会发生什么？

3，include暗黑操作三：
	如果include包含的文件存在，依赖文件更新了会发生什么？
4，include总结
	当目标文件不存在
		以文件名查找规则，并执行
	当目标文件不存在，且查找到的规则中创建了目标文件
		将创建成功的目标文件包含进当前makefile
	当目标文件存在
		将目标文件包含进当前makefile
		以目标文件名查找是否有相应规则
			YES：比较规则的依赖关系，决定是否执行规则命令
			NO：NULL(无操作)
	当目标文件存在，且目标名对应的规则被执行
		规则中的命令更新了目标文件
			make重新包含目标文件，替换之前包含的内容
		目标文件未被更新
			NULL(无操作)
			
第14课 自动生成依赖关系-续
1，注意事项
	当.dep文件生成后，如果动态的改变头文件间的依赖关系，那么make可能
	无法检测到这个改变，进而做出错误的编译决策
	
2，解决方案
	将依赖文件名作为目标加入自动生成的依赖关系中
	通过include加载依赖文件时判断是否执行规则
	在规则执行时重新生成依赖关系文件
	最后加载新的依赖文件

小结：
	makefile中可以将目标的依赖拆分写到不同的地方
	include关键字能够触发相应规则的执行
	如果规则的执行导致依赖更新，可能导致再次解释执行相应规则
	依赖文件也需要依赖于源文件得到正确的编译决策
	自动生成文件间的依赖关系能够提高makefile的移植性

第15课 make的隐式规则-上
问题：如果一个目标的命令拆分的写到不同地方，会发生什么？

1，makefile中出现同名目标时
	依赖：
		所有的依赖将合并在一起，成为目标的最终依赖
	命令：
		当多处出现同一目标的命令时，make发出警告
		所有之前定义的命令被最后定义的命令取代
注意事项
	当使用include关键字包含其它文件时，需要确保被包含文件中的
	同名目标只有依赖，命运命令；否则，同名目标的命令将被覆盖。

2，什么是隐式规则(built-in rules)?
	make提供了一些常用的，例行的规则实现
	当相应目标的规则未提供时，make尝试使用隐式规则

初探隐式规则
	make提供了生成目标文件的隐式规则
	隐式规则会使用预定义变量完成编译工作
	改变预定义变量将部分改变隐式规则的行为
	当存在自定义规则时，不在使用隐式规则
	
小结
	当多处出现同一目标的命令时，只有最后定义的命令有效
	make提供了一系列的隐式规则可使用
	当makefile中未定义相关规则时，尝试使用隐式规则
	隐式规则中可能使用make中的预定义变量
	改变预定义变量可部分改变预定义规则的行为
	
第16课 make的隐式规则-下
1，深入理解隐式规则
	当make发现目标的依赖不存在时
		尝试通过依赖名逐一查找隐式规则
		并且通过依赖名推导可能需要的源文件
		app.out : main.o func.o
			$(CC) -o $@ $^
		1，发现目标依赖不存在
		2，查找隐式规则，并自动推导出：func.o : func.c
		3，根据文件后缀自动推导编译命令：cc -c -o func.o func.c
		
2，隐式规则的副作用
	编译行为难以控制
		大量使用隐式规则可能产生意想不到的编译行为
	编译效率低下
		make从隐式规则和自定义规则中选择最终使用的规则
		
3，隐式规则链
	当依赖的目标不存在时，make会极力组合各种隐式规则对目标进行创建，
	进而产生意料之外的编译行为！
	
4，查看隐式规则
	查看所有： make -p
	查看具体规则： make -p | grep "XXX"
	例： make -p | grep "%.o"
	
5，隐式规则的禁用
	局部禁用
		在makefile中自定义规则
		在makefile中定义模式(如： %.o : %.p ; 相当于空规则)
	全局禁用
		make -r
		
6，后缀规则简介
	后缀规则是旧式的"模式规则"
	可通过后缀描述的方式自定义规则
	.cpp.o :
		g++ -o $@ -c $^
	(.ccp.o)通过.cpp文件产生.o文件(例： func.cpp -> func.o)
	
	双后缀规则
		定义一对文件后缀(依赖文件后缀和目标文件后缀)
			如：.cpp.o <-> %.o : %.cpp
	单后缀规则
		定义单个文件后缀(源文件后缀)
			如： .c <-> % : %.c

7，关于后缀规则的注意事项
	后缀规则中不允许有依赖
	后缀规则必须有命令，否则无意义
	后缀规则将逐步被模式规则取代
	
小结
	隐式规则可能造成意想不到的编译行为
	在实际工程项目中尽量不使用隐式规则
	后缀规则是一种旧式的规则模式
	后缀规则正逐步被模式规则取代
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
