第1课
1，make是一个应用程序
	解析源程序之间的依赖关系
	根据依赖关系自动维护编译工作
	执行宿主操作系统中的各种命令

2，makefile是一个描述文件
	定义一系列的规则来指定源文件编译的先后顺序
	拥有特定的语法规则，支持函数定义和函数调用
	能够直接集成操作系统中的各种命令

3，最简单的makefile示例
	hello：
		echo "hello makefile"
	目标	实现目标所执行的命令
注意：目标后的命令需要用tab键('\t')隔开。

4，make程序的使用示例
	make -f mf.txt hello
功能说明：
	以hello关键字作为目标查找mf.txt文件，并执行hello处的命令。

5，make程序的简写示例
	make hello
功能说明：
	以hello关键字作为目标查找makefile或者Makefile文件，并执行hello处的命令。

	make
功能说明：
	查找makefile或Makefile文件中最顶层目标，并执行最顶层目标的命令。

小结：
	make只是一个特殊功能的应用程序
	make用于根据指定的目标执行相应的命令
	makefile用于定义目标和实现目标所需的命令
	makefile有特定的语法规则，支持函数定义和调用

第2课
1，makefile的意义
	makefile用于定义源文件间的依赖关系
	makefile说明如何编译各个源文件并生成可执行文件
依赖的定义：
	targets : prerequistes ; command1
		('\t')command2

2, makefile中的元素含义
	targets
		通常是需要生成的目标文件名
		make所需执行的命令名称
	prerequisites
		当前目标所依赖的其它目标或文件
	command
		完成目标所需要执行的命令

3，规则中的注意事项
	targets可以包含多个目标
		使用空格对多个目标名进行分隔
	prerequisites可以包含多个依赖
		使用空格对多个依赖进行分隔
	tab键：'\t'
		每一个命令行必须以tab字符开始
		tab字符告诉make此行是一个命令行
	续行符：\
		可以将内容分开写到下一行，提高可读性

4，依赖规则
	当目标对应的文件不存在，执行对应命令
	当依赖在时间上比目标更新，执行对应命令
	当依赖关系连续发生时，对比依赖链上的每一个目标

5，小技巧
	makefile中可以在命令前加上@符，作用为命令无回显
	工程开发中可以将最终可执行文件名和all同时作为makefile中第一条规则的目标。
	hello.out all : main.c
		gcc -o hello.out main.o

小结：
	makefile用于定义原文件间的依赖关系
	makefile说明如何编译各个源文件并生成可执行文件
	makefile中的目标之间存在连续依赖关系
	依赖存在并且命令执行成功时目标完成的充要条件

第3课
1，makefile中的伪目标
	通过.PHONY关键字声明一个伪目标
	伪目标不对应任何实际的文件
	不管伪目标的依赖是否更新，命令总是执行

2，伪目标的语法：先声明，后使用
	本质：
	伪目标是make中的特殊目标.PHONY的依赖
	.PHONY : clean
	## 注释 ##
	clean :
		command

3, 伪目标的妙用：规则调用(函数调用)
	.PHONY : clean rebuild all
	## other rules ##
	rebuild : clean all
	clean : 
		command
原理：当一个目标的依赖包含伪目标时伪目标所定义的命令总是会被执行。

技巧：绕开.PHONY关键字定义伪目标
原理：如果一个规则没有命令或者依赖，并且它的目标不是一个存在的文件名；
在执行此规则时，目标总会被认为是最新的。
	clean : FORCE
		command
	FORCE :

第4课
makefile中支持程序设计语言中变量的概念
makefile中的变量只代表文本数据(字符串)
makefile中的变量名规则
	- 变量名可以包含字符，数字，下划线
	- 不能包含":","#","="或" "
	- 变量名大小写敏感
	
1，变量的定义和使用
	CC := gcc
	TARGET := hello.out
	
	$(TARGET) : main.o
		$(CC) -o $(TARGET) main.o

2, makefile中变量赋值方式
	- 简单赋值( := )
	- 递归赋值( = )
	- 条件赋值( ?= )
	- 追加赋值( += )

3, 简单赋值
	程序设计语言中的通用的赋值方式
	只针对当前语句的变量有效
	x := foo
	y := $(x)b
	x := new
	.PHONY : test
	test :
		@echo "x => $(x)"
		@echo "y => $(y)"
	输出： x => new; y => foob
	
4, 递归赋值
	赋值操作可能影响多个其它变量
	所有与目标变量相关的其它变量都将受到影响
	x := foo
	y := $(x)b
	x := new
	输出： x => new; y => newb
	
5，条件赋值
	如果变量未定义，使用赋值符号中的值定义变量
	如果变量已经定义，赋值无效
	x := foo
	y := $(x)b
	x ?= new
	输出： x => foo; y => foob
	
6，追加赋值
	原变量之后加上一个新值
	原变量值与新值之间由空格隔开
	x := foo
	y := $(x)b
	x += $(y)
	输出： x => foo foob; y => foob
	
第5课
1，预定义变量的使用
在makefile中存在一些预定义的变量
	自动变量
		$@ 当前规则中触发命令被执行的目标
		$^ 当前规则中的所有依赖
		$< 当前规则中的第一个依赖
	特殊变量
		$(MAKE) 当前make解释器的文件名
		$(NAKECMDGOALS) 命令行中指定的目标名(make的命令行参数)
		$(MAKEFILE_LIST) make所需要处理的makefile文件列表，当前makefile的文件名总是位于列表最后
						文件名之间以空格进行分隔
		$(MAKE_VERSION) 当前make解释器的版本
		$(CURDIR) 当前make解释器的工作目录
		$(.VARIABLES) 所有已定义的变量名列表(预定义变量和自定义变量)
		...

示例：
	all : first second third
		@echo "\$$@ => $@"
		@echo "$$^ => $^"
		@echo "$$< => $<"
		
注意：
1，"$"对于makefile有特殊含义，输出时需要加上一个"$"
2，"$@"对于Base Shell有特殊含义，输出时需要加上"\"进行转义

第6课
1，变量值的替换
	使用指定字符(串)替换变量值中的后缀字符(串)
	语法格式：$(var:a=b)或${var:a=b}
		替换表达式中不能有任何的空格
		make中支持使用${}对变量进行取值
		
2，变量的模式替换
	使用%保留变量值中的指定字符，替换其它字符
	语法格式: $(var:a%b=x%y)或${var:a%b=x%y}
		替换表达式中不能有任何的空格
		make中支持使用${}对变量进行取值
		
3，规则中的模式替换
	targets : target-pattern : prereq-pattern
		command1
		command2
		...
意义：通过target-pattern从targets中匹配子目标；在通过prereq-pattern
从子目标生成依赖；进而构成完整的规则。
示例：
	OBJS := func.o main.o
	$(OBJS) : %.o : %.c
		gcc -o $@ -c $^
等价于
	func.o : func.c
		gcc -o $@ -c $^
	main.o : main.c
		gcc -o $@ -c $^

4，变量值的嵌套引用
	一个变量名之中可以包含对其它变量的引用
	嵌套引用的本质是使用一个变量表示另外一个变量
	x := y
	y := z
	a := $($(x))
	=> a := $(y) => a := z
	
5，命令行变量
	运行make时，在命令行定义变量
	命令行变量默认覆盖makefile中定义的变量
	注意：命令行变量不能有空格(a:=b)
	
6，override关键字
	用于指示makefile中定义的变量不能被覆盖
	变量的定义和赋值都需要使用override关键字
	
7，define关键字
	用于在makefile中定义多行变量
	多行变量的定义从变量名开始到endef结束
	可使用override关键字防止变量被覆盖
	define定义的变量等价于使用 = 定义的变量
override define cmd
	@echo "run cmd ls ..."
	@echo ls
endef

第7课
1，环境变量(全局变量)
	makefile中能够直接使用环境变量的值
		定义了同名变量，环境变量将被覆盖
		运行make时指定"-e"选项，优先使用环境变量
	为什么要在makefile中使用环境变量？
		优势：环境变量可以在所有makefile中使用
		劣势：过多的依赖于环境变量会导致移植性降低
		
2，变量在不同makefile之间的传递方式
	直接在外部定义环境变量进行传递
	使用export定义比那辆进行传递(定义临时环境变量)
	定义make命令行变量进行传递(推荐)

3，目标变量(局部变量)
	作用域只在指定目标及连带规则中
	target : name <assignment> value
	target : override name <assignment> value
	
4，模式变量
	模式变量是目标变量的扩展
	作用域只在符合模式的目标及连带规则中
	pattern : name <assignment> value
	pattern : override name <assignment> value
	
第8课
1，makefile中支持条件判断语句
	可以根据条件的值来决定make的执行
	可以比较两个不同变量或者变量和常量值
	if*** (arg1,arg2)
	# for true
	else
	# for false
	endif
注意事项：条件判断语句只能用于控制make实际执行的语句；但是不能控制规则中命令的执行过程。

2，条件判断语句语法说明
	常用形式
		if*** (arg1,arg2)
	其它合法形式
		if*** "arg1" "arg2"
		if*** 'arg1' "arg2"
		if*** "arg1" 'arg2'
		if*** 'arg1' 'arg2'
注意：
	 	   		不能有空格(arg1,arg2)
[space]if***[space](arg1,arg2)[space]    

3，条件判断关键字
	ifeq	判断参数是否相等，相等为true，否则为false
	ifneq	判断参数是否不相等，不相等为true，否则为false
	ifdef	判断变量是否有值，有值为true，否则为false
	ifndef	判断参数是否没有值，没有值为true，否则为false

4，工程经验
	条件判断语句之前可以有空格，但不能有Tab字符('\t')
	在条件语句中不要使用自动变量($@, $^, $<)
	一条完整的条件语句必须位于同一个makefile中
	条件判断类似C语言中的宏，预处理阶段有效，执行阶段无效
	make在加载makefile时
		首先计算表达式的值(赋值方式不同，计算方式不同)
		根据判断语句的表达式决定执行的内容
		
第9课
1，makefile中支持函数的概念
	make解释器提供了一系列的函数供makefile调用
	在makefile中支持自定义函数实现，并调用执行
	通过define关键字实现自定义函数
	
2，自定义函数语法
函数定义：
	define func1
		@echo "My name is $(0)."
	endef
	
	define func2
		@echo "My name is $(0)."
		@echo "Param => $(1)"
	endef
	
函数调用：
	test :
		$(call func1)
		$(call func2, chichi)

3，深入理解自定义函数
	自定义函数是一个多行变量，无法直接调用
	自定义函数是一种过程调用，没有任何的返回值
	定义函数用于定义命令集合，并应用于规则中

4，make解释器中的预定义函数
	make的函数提供了处理文件名，变量和命令的函数
	可以在需要的地方调用函数来处理指定的参数
	函数在调用的地方被替换为处理结果
5, 预定义函数的调用
	var := $(func_name arg1,arg2, ...)
	为什么和自定义函数调用方式不同？
	本质剖析：
		makefile中不支持真正意义上的自定义函数
		自定义函数的本质是多行变量
		预定义的call函数在调用时将参数传递给多行变量
		自定义函数是call函数的实参，并在call中被执行


